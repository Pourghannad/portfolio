<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Rectangles with Dynamic Lighting</title>
    <style>
        body { 
            margin: 0; 
            padding: 0; 
            overflow: hidden; 
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        canvas { 
            display: block; 
            cursor: move;
            border: 1px solid #333;
        }
    </style>
</head>
<body>
    <canvas id="glCanvas" width="800" height="600"></canvas>

    <script>
        // WebGL context
        const canvas = document.getElementById('glCanvas');
        const gl = canvas.getContext('webgl');
        
        if (!gl) {
            alert('WebGL not supported');
            throw new Error('WebGL not supported');
        }

        console.log('WebGL context created successfully');

        // Enable depth testing
        gl.enable(gl.DEPTH_TEST);
        gl.clearColor(0.0, 0.05, 0.1, 1.0);

        // Vertex shader with explicit precision
        const vsSource = `
            precision mediump float;
            attribute vec2 aPosition;
            uniform mat4 uModelViewMatrix;
            uniform mat4 uProjectionMatrix;
            uniform vec2 uMousePos;
            uniform float uInfluenceRadius;
            uniform float uTime;
            
            void main() {
                vec2 position = aPosition;
                
                // Calculate distance from this rectangle to mouse
                float dist = distance(position, uMousePos);
                
                // Only move rectangles within influence radius
                if (dist < uInfluenceRadius) {
                    // Calculate influence factor
                    float influence = 1.0 - (dist / uInfluenceRadius);
                    influence = influence * influence; // Quadratic falloff
                    
                    // Push away from mouse
                    vec2 dir = normalize(position - uMousePos);
                    position += dir * influence * 0.15;
                }
                
                gl_Position = uProjectionMatrix * uModelViewMatrix * vec4(position, 0.0, 1.0);
            }
        `;

        // Fragment shader with dynamic lighting
        const fsSource = `
            precision mediump float;
            uniform vec2 uMousePos;
            uniform float uTime;
            uniform vec3 uLightColor;
            
            void main() {
                // Base blue color
                vec3 baseColor = vec3(0.0, 0.4, 1.0);
                
                // Mouse proximity effect
                vec2 coord = gl_FragCoord.xy / 800.0;
                float mouseDist = distance(coord, (uMousePos + 1.0) * 0.5);
                float mouseGlow = 1.0 - smoothstep(0.0, 0.4, mouseDist);
                
                // Pulsing effect
                float pulse = sin(uTime * 3.0) * 0.1 + 0.9;
                
                // Combine effects
                vec3 finalColor = baseColor * uLightColor * pulse * (1.0 + mouseGlow * 0.3);
                
                gl_FragColor = vec4(finalColor, 1.0);
            }
        `;

        // Compile shader
        function compileShader(source, type) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compile error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        // Create shader program
        const vertexShader = compileShader(vsSource, gl.VERTEX_SHADER);
        const fragmentShader = compileShader(fsSource, gl.FRAGMENT_SHADER);
        
        if (!vertexShader || !fragmentShader) {
            throw new Error('Shader compilation failed');
        }
        
        const shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);
        
        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            console.error('Program link error:', gl.getProgramInfoLog(shaderProgram));
            throw new Error('Program linking failed');
        }
        
        gl.useProgram(shaderProgram);
        console.log('Shader program created successfully');

        // Get attribute and uniform locations
        const aPosition = gl.getAttribLocation(shaderProgram, 'aPosition');
        const uModelViewMatrix = gl.getUniformLocation(shaderProgram, 'uModelViewMatrix');
        const uProjectionMatrix = gl.getUniformLocation(shaderProgram, 'uProjectionMatrix');
        const uMousePos = gl.getUniformLocation(shaderProgram, 'uMousePos');
        const uInfluenceRadius = gl.getUniformLocation(shaderProgram, 'uInfluenceRadius');
        const uTime = gl.getUniformLocation(shaderProgram, 'uTime');
        const uLightColor = gl.getUniformLocation(shaderProgram, 'uLightColor');

        console.log('Uniform locations found:', {
            aPosition: aPosition,
            uModelViewMatrix: !!uModelViewMatrix,
            uProjectionMatrix: !!uProjectionMatrix,
            uMousePos: !!uMousePos,
            uInfluenceRadius: !!uInfluenceRadius,
            uTime: !!uTime,
            uLightColor: !!uLightColor
        });

        // Enable attributes
        gl.enableVertexAttribArray(aPosition);

        // Grid configuration for rectangles
        const cols = 12;
        const rows = 8;
        const rectWidth = 0.08;
        const rectHeight = 0.06;
        const spacing = 0.15;

        const startX = -(cols - 1) * spacing / 2;
        const startY = -(rows - 1) * spacing / 2;

        // Create vertex data for rectangles (2 triangles per rectangle)
        const positions = [];
        
        for (let row = 0; row < rows; row++) {
            for (let col = 0; col < cols; col++) {
                const centerX = startX + col * spacing;
                const centerY = startY + row * spacing;
                
                const halfWidth = rectWidth / 2;
                const halfHeight = rectHeight / 2;
                
                // First triangle - bottom-left, bottom-right, top-left
                positions.push(centerX - halfWidth, centerY - halfHeight); // bottom-left
                positions.push(centerX + halfWidth, centerY - halfHeight); // bottom-right
                positions.push(centerX - halfWidth, centerY + halfHeight); // top-left
                
                // Second triangle - top-left, bottom-right, top-right
                positions.push(centerX - halfWidth, centerY + halfHeight); // top-left
                positions.push(centerX + halfWidth, centerY - halfHeight); // bottom-right
                positions.push(centerX + halfWidth, centerY + halfHeight); // top-right
            }
        }

        console.log(`Created ${positions.length / 12} rectangles (${positions.length / 2} vertices)`);

        // Create buffer
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

        // Set up attribute pointer
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);

        // Initialize matrices
        let modelViewMatrix = new Float32Array(16);
        let projectionMatrix = new Float32Array(16);

        // Matrix functions
        function perspective(out, fovy, aspect, near, far) {
            const f = 1.0 / Math.tan(fovy / 2);
            const nf = 1 / (near - far);
            out[0] = f / aspect;
            out[1] = 0; out[2] = 0; out[3] = 0;
            out[4] = 0; out[5] = f; out[6] = 0; out[7] = 0;
            out[8] = 0; out[9] = 0; out[10] = (far + near) * nf; out[11] = -1;
            out[12] = 0; out[13] = 0; out[14] = (2 * far * near) * nf; out[15] = 0;
            return out;
        }

        function lookAt(out, eye, center, up) {
            let x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
            const eyex = eye[0], eyey = eye[1], eyez = eye[2];
            const upx = up[0], upy = up[1], upz = up[2];
            const centerx = center[0], centery = center[1], centerz = center[2];

            z0 = eyex - centerx; z1 = eyey - centery; z2 = eyez - centerz;
            len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
            z0 *= len; z1 *= len; z2 *= len;

            x0 = upy * z2 - upz * z1; x1 = upz * z0 - upx * z2; x2 = upx * z1 - upy * z0;
            len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
            if (!len) { x0 = 0; x1 = 0; x2 = 0; } else { len = 1 / len; x0 *= len; x1 *= len; x2 *= len; }

            y0 = z1 * x2 - z2 * x1; y1 = z2 * x0 - z0 * x2; y2 = z0 * x1 - z1 * x0;
            len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
            if (!len) { y0 = 0; y1 = 0; y2 = 0; } else { len = 1 / len; y0 *= len; y1 *= len; y2 *= len; }

            out[0] = x0; out[1] = y0; out[2] = z0; out[3] = 0;
            out[4] = x1; out[5] = y1; out[6] = z1; out[7] = 0;
            out[8] = x2; out[9] = y2; out[10] = z2; out[11] = 0;
            out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
            out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
            out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
            out[15] = 1;
            return out;
        }

        // Mouse interaction and lighting
        let mouseX = 0;
        let mouseY = 0;
        let targetMouseX = 0;
        let targetMouseY = 0;
        const influenceRadius = 0.3;
        let lightColor = [1.0, 1.0, 1.0];
        let startTime = Date.now();

        canvas.addEventListener('mousemove', (event) => {
            const rect = canvas.getBoundingClientRect();
            targetMouseX = ((event.clientX - rect.left) / canvas.width) * 2 - 1;
            targetMouseY = -((event.clientY - rect.top) / canvas.height) * 2 + 1;
            
            // Change light color based on mouse position
            lightColor[0] = 0.7 + Math.abs(targetMouseX) * 0.3; // Red
            lightColor[1] = 0.7 + Math.abs(targetMouseY) * 0.3; // Green
            lightColor[2] = 1.0; // Blue
        });

        // Render loop
        function render() {
            const currentTime = (Date.now() - startTime) * 0.001;
            
            // Clear
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            
            // Smooth mouse movement
            mouseX += (targetMouseX - mouseX) * 0.2;
            mouseY += (targetMouseY - mouseY) * 0.2;
            
            // Set up projection matrix
            perspective(projectionMatrix, Math.PI / 4, canvas.width / canvas.height, 0.1, 100.0);
            
            // Set up model-view matrix
            const eye = [0, 0, 3];
            const center = [0, 0, 0];
            const up = [0, 1, 0];
            lookAt(modelViewMatrix, eye, center, up);
            
            // Set uniforms
            gl.uniformMatrix4fv(uProjectionMatrix, false, projectionMatrix);
            gl.uniformMatrix4fv(uModelViewMatrix, false, modelViewMatrix);
            gl.uniform2f(uMousePos, mouseX, mouseY);
            gl.uniform1f(uInfluenceRadius, influenceRadius);
            gl.uniform1f(uTime, currentTime);
            gl.uniform3fv(uLightColor, lightColor);
            
            // Draw rectangles (6 vertices per rectangle)
            gl.drawArrays(gl.TRIANGLES, 0, positions.length / 2);
            
            requestAnimationFrame(render);
        }

        // Start rendering
        console.log('Starting render loop...');
        render();

        console.log('3D Rectangles with Dynamic Lighting - WORKING!');
        console.log('Move mouse around:');
        console.log('- Nearby rectangles move away from cursor');
        console.log('- Lighting color changes based on mouse position');
        console.log('- Pulsing effect adds dynamic feel');
        console.log(`Grid: ${cols} × ${rows} rectangles`);
    </script>
</body>
</html>