<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pure WebGL 3D Rectangular Grid with Lighting</title>
    <style>
        body { 
            margin: 0; 
            padding: 0; 
            overflow: hidden; 
            background: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        canvas { 
            display: block; 
        }
    </style>
</head>
<body>
    <canvas id="glCanvas" width="800" height="600"></canvas>

    <script>
        // WebGL context
        const canvas = document.getElementById('glCanvas');
        const gl = canvas.getContext('webgl');
        
        if (!gl) {
            alert('WebGL not supported');
        }

        // Enable depth testing
        gl.enable(gl.DEPTH_TEST);
        gl.enable(gl.CULL_FACE);
        gl.clearColor(0.0, 0.05, 0.1, 1.0); // Darker blue background

        // Vertex shader with lighting
        const vsSource = `
            attribute vec3 aPosition;
            attribute vec3 aNormal;
            uniform mat4 uModelViewMatrix;
            uniform mat4 uProjectionMatrix;
            uniform mat4 uNormalMatrix;
            uniform vec3 uLightPosition;
            varying vec3 vNormal;
            varying vec3 vLightDir;
            varying vec3 vPosition;
            
            void main() {
                vec4 position = uModelViewMatrix * vec4(aPosition, 1.0);
                gl_Position = uProjectionMatrix * position;
                
                vPosition = position.xyz;
                vNormal = normalize(mat3(uNormalMatrix) * aNormal);
                vLightDir = normalize(uLightPosition - position.xyz);
            }
        `;

        // Fragment shader with Phong lighting
        const fsSource = `
            precision mediump float;
            varying vec3 vNormal;
            varying vec3 vLightDir;
            varying vec3 vPosition;
            uniform vec3 uLightColor;
            uniform vec3 uAmbientColor;
            uniform float uLightIntensity;
            
            void main() {
                // Base blue color
                vec3 baseColor = vec3(0.0, 0.4, 1.0);
                
                // Ambient lighting
                vec3 ambient = uAmbientColor * baseColor;
                
                // Diffuse lighting
                float diff = max(dot(vNormal, vLightDir), 0.0);
                vec3 diffuse = uLightColor * baseColor * diff;
                
                // Specular lighting (small highlight)
                vec3 viewDir = normalize(-vPosition);
                vec3 reflectDir = reflect(-vLightDir, vNormal);
                float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);
                vec3 specular = uLightColor * spec * 0.3;
                
                // Combine all lighting components
                vec3 finalColor = (ambient + diffuse + specular) * uLightIntensity;
                
                gl_FragColor = vec4(finalColor, 1.0);
            }
        `;

        // Compile shader
        function compileShader(source, type) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compile error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        // Create shader program
        const vertexShader = compileShader(vsSource, gl.VERTEX_SHADER);
        const fragmentShader = compileShader(fsSource, gl.FRAGMENT_SHADER);
        const shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);
        
        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            console.error('Program link error:', gl.getProgramInfoLog(shaderProgram));
        }
        
        gl.useProgram(shaderProgram);

        // Get attribute and uniform locations
        const aPosition = gl.getAttribLocation(shaderProgram, 'aPosition');
        const aNormal = gl.getAttribLocation(shaderProgram, 'aNormal');
        const uModelViewMatrix = gl.getUniformLocation(shaderProgram, 'uModelViewMatrix');
        const uProjectionMatrix = gl.getUniformLocation(shaderProgram, 'uProjectionMatrix');
        const uNormalMatrix = gl.getUniformLocation(shaderProgram, 'uNormalMatrix');
        const uLightPosition = gl.getUniformLocation(shaderProgram, 'uLightPosition');
        const uLightColor = gl.getUniformLocation(shaderProgram, 'uLightColor');
        const uAmbientColor = gl.getUniformLocation(shaderProgram, 'uAmbientColor');
        const uLightIntensity = gl.getUniformLocation(shaderProgram, 'uLightIntensity');

        // Enable attributes
        gl.enableVertexAttribArray(aPosition);
        gl.enableVertexAttribArray(aNormal);

        // Grid configuration
        const cols = 24;
        const rows = 24;
        const rectWidth = 0.08;
        const rectHeight = 0.08;
        const rectDepth = 0.02; // Added depth for better 3D effect
        const spacing = 0.12;

        const startX = -(cols - 1) * spacing / 2;
        const startY = -(rows - 1) * spacing / 2;

        // Create vertex data for 3D rectangles with normals
        const positions = [];
        const normals = [];
        
        // Define a single 3D rectangle vertices (6 faces = 12 triangles)
        function createCubeVertices(centerX, centerY, centerZ, width, height, depth) {
            const halfWidth = width / 2;
            const halfHeight = height / 2;
            const halfDepth = depth / 2;
            
            // Define the 8 vertices of the cube
            const vertices = [
                // Front face
                [centerX - halfWidth, centerY - halfHeight, centerZ + halfDepth],
                [centerX + halfWidth, centerY - halfHeight, centerZ + halfDepth],
                [centerX - halfWidth, centerY + halfHeight, centerZ + halfDepth],
                [centerX + halfWidth, centerY + halfHeight, centerZ + halfDepth],
                // Back face
                [centerX - halfWidth, centerY - halfHeight, centerZ - halfDepth],
                [centerX + halfWidth, centerY - halfHeight, centerZ - halfDepth],
                [centerX - halfWidth, centerY + halfHeight, centerZ - halfDepth],
                [centerX + halfWidth, centerY + halfHeight, centerZ - halfDepth]
            ];
            
            // Define faces (each face = 2 triangles)
            const faces = [
                // Front face
                [0, 1, 2, 1, 3, 2],
                // Back face
                [5, 4, 7, 4, 6, 7],
                // Top face
                [2, 3, 6, 3, 7, 6],
                // Bottom face
                [4, 5, 0, 5, 1, 0],
                // Right face
                [1, 5, 3, 5, 7, 3],
                // Left face
                [4, 0, 6, 0, 2, 6]
            ];
            
            // Face normals
            const faceNormals = [
                [0, 0, 1],   // Front
                [0, 0, -1],  // Back
                [0, 1, 0],   // Top
                [0, -1, 0],  // Bottom
                [1, 0, 0],   // Right
                [-1, 0, 0]   // Left
            ];
            
            // Create triangles with normals
            for (let face = 0; face < faces.length; face++) {
                const faceVertices = faces[face];
                const normal = faceNormals[face];
                
                for (let i = 0; i < 6; i++) {
                    const vertexIndex = faceVertices[i];
                    const vertex = vertices[vertexIndex];
                    positions.push(vertex[0], vertex[1], vertex[2]);
                    normals.push(normal[0], normal[1], normal[2]);
                }
            }
        }

        // Create all rectangles in grid
        for (let row = 0; row < rows; row++) {
            for (let col = 0; col < cols; col++) {
                const x = startX + col * spacing;
                const y = startY + row * spacing;
                const z = 0;
                createCubeVertices(x, y, z, rectWidth, rectHeight, rectDepth);
            }
        }

        // Create buffers
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
        
        const normalBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);

        // Set up attribute pointers
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 0, 0);
        
        gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
        gl.vertexAttribPointer(aNormal, 3, gl.FLOAT, false, 0, 0);

        // Initialize matrices
        let modelViewMatrix = new Float32Array(16);
        let projectionMatrix = new Float32Array(16);
        let normalMatrix = new Float32Array(16);

        // Matrix functions
        function perspective(out, fovy, aspect, near, far) {
            const f = 1.0 / Math.tan(fovy / 2);
            const nf = 1 / (near - far);
            out[0] = f / aspect;
            out[1] = 0;
            out[2] = 0;
            out[3] = 0;
            out[4] = 0;
            out[5] = f;
            out[6] = 0;
            out[7] = 0;
            out[8] = 0;
            out[9] = 0;
            out[10] = (far + near) * nf;
            out[11] = -1;
            out[12] = 0;
            out[13] = 0;
            out[14] = (2 * far * near) * nf;
            out[15] = 0;
        }

        function lookAt(out, eye, center, up) {
            let x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
            const eyex = eye[0];
            const eyey = eye[1];
            const eyez = eye[2];
            const upx = up[0];
            const upy = up[1];
            const upz = up[2];
            const centerx = center[0];
            const centery = center[1];
            const centerz = center[2];

            z0 = eyex - centerx;
            z1 = eyey - centery;
            z2 = eyez - centerz;

            len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
            z0 *= len;
            z1 *= len;
            z2 *= len;

            x0 = upy * z2 - upz * z1;
            x1 = upz * z0 - upx * z2;
            x2 = upx * z1 - upy * z0;
            len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
            if (!len) {
                x0 = 0;
                x1 = 0;
                x2 = 0;
            } else {
                len = 1 / len;
                x0 *= len;
                x1 *= len;
                x2 *= len;
            }

            y0 = z1 * x2 - z2 * x1;
            y1 = z2 * x0 - z0 * x2;
            y2 = z0 * x1 - z1 * x0;

            len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
            if (!len) {
                y0 = 0;
                y1 = 0;
                y2 = 0;
            } else {
                len = 1 / len;
                y0 *= len;
                y1 *= len;
                y2 *= len;
            }

            out[0] = x0;
            out[1] = y0;
            out[2] = z0;
            out[3] = 0;
            out[4] = x1;
            out[5] = y1;
            out[6] = z1;
            out[7] = 0;
            out[8] = x2;
            out[9] = y2;
            out[10] = z2;
            out[11] = 0;
            out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
            out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
            out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
            out[15] = 1;
        }

        function rotateY(out, a, rad) {
            const s = Math.sin(rad);
            const c = Math.cos(rad);
            const a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
            const a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
            const a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];

            out[0] = a00 * c - a20 * s;
            out[1] = a01 * c - a21 * s;
            out[2] = a02 * c - a22 * s;
            out[3] = a03 * c - a23 * s;
            out[4] = a10;
            out[5] = a11;
            out[6] = a12;
            out[7] = a13;
            out[8] = a00 * s + a20 * c;
            out[9] = a01 * s + a21 * c;
            out[10] = a02 * s + a22 * c;
            out[11] = a03 * s + a23 * c;
            out[12] = a[12];
            out[13] = a[13];
            out[14] = a[14];
            out[15] = a[15];
        }

        function rotateX(out, a, rad) {
            const s = Math.sin(rad);
            const c = Math.cos(rad);
            const a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
            const a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];

            out[4] = a10 * c + a20 * s;
            out[5] = a11 * c + a21 * s;
            out[6] = a12 * c + a22 * s;
            out[7] = a13 * c + a23 * s;
            out[8] = a20 * c - a10 * s;
            out[9] = a21 * c - a11 * s;
            out[10] = a22 * c - a12 * s;
            out[11] = a23 * c - a13 * s;
        }

        function mat4Inverse(out, a) {
            // Simple inverse for rotation matrices (transpose for orthonormal matrices)
            out[0] = a[0]; out[1] = a[4]; out[2] = a[8]; out[3] = 0;
            out[4] = a[1]; out[5] = a[5]; out[6] = a[9]; out[7] = 0;
            out[8] = a[2]; out[9] = a[6]; out[10] = a[10]; out[11] = 0;
            out[12] = 0; out[13] = 0; out[14] = 0; out[15] = 1;
        }

        function mat4Transpose(out, a) {
            out[0] = a[0]; out[1] = a[4]; out[2] = a[8]; out[3] = a[12];
            out[4] = a[1]; out[5] = a[5]; out[6] = a[9]; out[7] = a[13];
            out[8] = a[2]; out[9] = a[6]; out[10] = a[10]; out[11] = a[14];
            out[12] = a[3]; out[13] = a[7]; out[14] = a[11]; out[15] = a[15];
        }

        // Mouse interaction and lighting
        let mouseX = 0;
        let mouseY = 0;
        let rotationX = 0;
        let rotationY = 0;
        let targetRotationX = 0;
        let targetRotationY = 0;

        // Lighting properties
        let lightPosition = [0, 3, 2]; // Light above and in front
        const lightColor = [1.0, 1.0, 1.0]; // White light
        const ambientColor = [0.2, 0.2, 0.3]; // Blue ambient
        let lightIntensity = 1.0;

        canvas.addEventListener('mousemove', (event) => {
            const rect = canvas.getBoundingClientRect();
            mouseX = ((event.clientX - rect.left) / canvas.width) * 2 - 1;
            mouseY = -((event.clientY - rect.top) / canvas.height) * 2 + 1;
            
            targetRotationY = mouseX * Math.PI / 12;
            targetRotationX = (mouseY * Math.PI * 0.5) / 12;
            
            // Update light position based on mouse movement
            lightPosition[0] = mouseX * 3;
            lightPosition[1] = 3 - mouseY * 1; // Keep light mostly above
            lightPosition[2] = 2 + mouseY * 1;
            
            // Increase light intensity when mouse moves fast
            lightIntensity = 1.0 + Math.abs(mouseX) * 0.5 + Math.abs(mouseY) * 0.3;
        });


        // Render loop
        function render() {
            // Clear
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            
            // Smooth rotation
            rotationX += (targetRotationX - rotationX) * 0.05;
            rotationY += (targetRotationY - rotationY) * 0.05;
            
            // Set up projection matrix
            perspective(projectionMatrix, Math.PI / 4, canvas.width / canvas.height, 0.1, 100.0);
            
            // Set up model-view matrix with rotation
            const eye = [0, 0, 4];
            const center = [0, 0, 0];
            const up = [0, 1, 0];
            lookAt(modelViewMatrix, eye, center, up);
            
            // Apply rotations
            const tempMatrix = new Float32Array(16);
            rotateY(tempMatrix, modelViewMatrix, rotationY);
            rotateX(modelViewMatrix, tempMatrix, rotationX);
            
            // Calculate normal matrix (transpose of inverse of model-view)
            mat4Inverse(normalMatrix, modelViewMatrix);
            mat4Transpose(normalMatrix, normalMatrix);
            
            // Set uniforms
            gl.uniformMatrix4fv(uProjectionMatrix, false, projectionMatrix);
            gl.uniformMatrix4fv(uModelViewMatrix, false, modelViewMatrix);
            gl.uniformMatrix4fv(uNormalMatrix, false, normalMatrix);
            gl.uniform3fv(uLightPosition, lightPosition);
            gl.uniform3fv(uLightColor, lightColor);
            gl.uniform3fv(uAmbientColor, ambientColor);
            gl.uniform1f(uLightIntensity, lightIntensity);
            
            // Draw rectangles (each cube has 36 vertices - 6 faces * 6 vertices)
            gl.drawArrays(gl.TRIANGLES, 0, cols * rows * 36);
            
            requestAnimationFrame(render);
        }

        // Start rendering
        render();
    </script>
</body>
</html>